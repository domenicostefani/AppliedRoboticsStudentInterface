<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAR2019: student Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LAR2019
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">student Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstudent_1_1Color__config.html">Color_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aacb26aebecf0a57160aadff8f4ac5429"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aacb26aebecf0a57160aadff8f4ac5429">pointsEquals</a> (Point pa, Point pb)</td></tr>
<tr class="separator:aacb26aebecf0a57160aadff8f4ac5429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99b5e1d9883a93f4f58b47121a06a8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ab99b5e1d9883a93f4f58b47121a06a8b">loadImage</a> (cv::Mat &amp;img_out, const string &amp;config_folder)</td></tr>
<tr class="separator:ab99b5e1d9883a93f4f58b47121a06a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ecb46160bae8229c5545d81499cbe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a71ecb46160bae8229c5545d81499cbe1">genericImageListener</a> (const cv::Mat &amp;img_in, string topic, const string &amp;config_folder)</td></tr>
<tr class="separator:a71ecb46160bae8229c5545d81499cbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbe12fa5f061a35e0d3df30bec1a872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structstudent_1_1Color__config.html">Color_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#abdbe12fa5f061a35e0d3df30bec1a872">read_colors</a> (const string &amp;config_folder)</td></tr>
<tr class="separator:abdbe12fa5f061a35e0d3df30bec1a872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31ebca52b34d038f0ef94d7aa81be13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ac31ebca52b34d038f0ef94d7aa81be13">tune_color_parameters</a> (const cv::Mat &amp;image, const string &amp;config_folder)</td></tr>
<tr class="separator:ac31ebca52b34d038f0ef94d7aa81be13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c862ea36dd735ed630bd4ade893d692"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a0c862ea36dd735ed630bd4ade893d692">extrinsicCalib</a> (const cv::Mat &amp;img_in, vector&lt; cv::Point3f &gt; object_points, const cv::Mat &amp;camera_matrix, cv::Mat &amp;rvec, cv::Mat &amp;tvec, const string &amp;config_folder)</td></tr>
<tr class="separator:a0c862ea36dd735ed630bd4ade893d692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0e094ceaac869cef0f5056d3a79452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a6f0e094ceaac869cef0f5056d3a79452">imageUndistort</a> (const cv::Mat &amp;img_in, cv::Mat &amp;img_out, const cv::Mat &amp;cam_matrix, const cv::Mat &amp;dist_coeffs, const string &amp;config_folder)</td></tr>
<tr class="separator:a6f0e094ceaac869cef0f5056d3a79452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab4b372a0d7817c60ac1315991a3d24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#abab4b372a0d7817c60ac1315991a3d24">findPlaneTransform</a> (const cv::Mat &amp;cam_matrix, const cv::Mat &amp;rvec, const cv::Mat &amp;tvec, const vector&lt; cv::Point3f &gt; &amp;object_points_plane, const vector&lt; cv::Point2f &gt; &amp;dest_image_points_plane, cv::Mat &amp;plane_transf, const string &amp;config_folder)</td></tr>
<tr class="separator:abab4b372a0d7817c60ac1315991a3d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e350455611261c051053268de6d579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#af1e350455611261c051053268de6d579">unwarp</a> (const cv::Mat &amp;img_in, cv::Mat &amp;img_out, const cv::Mat &amp;transf, const string &amp;config_folder)</td></tr>
<tr class="separator:af1e350455611261c051053268de6d579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86371df933f2682ffb543020c09b9b37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a86371df933f2682ffb543020c09b9b37">findObstacles</a> (const cv::Mat &amp;hsv_img, const double scale, vector&lt; Polygon &gt; &amp;obstacle_list, const <a class="el" href="structstudent_1_1Color__config.html">Color_config</a> &amp;color_config)</td></tr>
<tr class="separator:a86371df933f2682ffb543020c09b9b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac147aa0ef901ceb20469551084e92583"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ac147aa0ef901ceb20469551084e92583">findGate</a> (const cv::Mat &amp;hsv_img, const double scale, Polygon &amp;gate, const <a class="el" href="structstudent_1_1Color__config.html">Color_config</a> &amp;color_config)</td></tr>
<tr class="separator:ac147aa0ef901ceb20469551084e92583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae736e2baa1e7b96612cea01993e5969a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ae736e2baa1e7b96612cea01993e5969a">findVictims</a> (const cv::Mat &amp;hsv_img, const double scale, vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;victim_list, const <a class="el" href="structstudent_1_1Color__config.html">Color_config</a> &amp;color_config, const string &amp;config_folder)</td></tr>
<tr class="separator:ae736e2baa1e7b96612cea01993e5969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f3ef58b787dd48aa05c05e4dc4e8b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#af4f3ef58b787dd48aa05c05e4dc4e8b7">processMap</a> (const cv::Mat &amp;img_in, const double scale, vector&lt; Polygon &gt; &amp;obstacle_list, vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;victim_list, Polygon &amp;gate, const string &amp;config_folder)</td></tr>
<tr class="separator:af4f3ef58b787dd48aa05c05e4dc4e8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1ef0c7d0350a8c3a84078bd7cfb14f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#afa1ef0c7d0350a8c3a84078bd7cfb14f">baricenter</a> (const Polygon &amp;polygon, double &amp;cx, double &amp;cy)</td></tr>
<tr class="separator:afa1ef0c7d0350a8c3a84078bd7cfb14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56a77ece3c368e8190419f5fa703a2f"><td class="memItemLeft" align="right" valign="top">Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#af56a77ece3c368e8190419f5fa703a2f">baricenter</a> (const Polygon &amp;polygon)</td></tr>
<tr class="separator:af56a77ece3c368e8190419f5fa703a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae962c3cdbd728fb697fc39c8e946ffc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ae962c3cdbd728fb697fc39c8e946ffc2">findRobot</a> (const cv::Mat &amp;img_in, const double scale, Polygon &amp;triangle, double &amp;x, double &amp;y, double &amp;theta, const string &amp;config_folder)</td></tr>
<tr class="separator:ae962c3cdbd728fb697fc39c8e946ffc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b73564a32b0038042221449619b34ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a0b73564a32b0038042221449619b34ef">centerGate</a> (const Polygon &amp;gate, const Polygon &amp;borders, double &amp;x, double &amp;y, double &amp;theta)</td></tr>
<tr class="separator:a0b73564a32b0038042221449619b34ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b0bbd19b5e7e10ee5c0c895266e72e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a14b0bbd19b5e7e10ee5c0c895266e72e">isArcColliding</a> (dubins::Arc a, Point pA, Point pB)</td></tr>
<tr class="separator:a14b0bbd19b5e7e10ee5c0c895266e72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bfc131afebdd7aa895617dbacaaa54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a80bfc131afebdd7aa895617dbacaaa54">isSegmentColliding</a> (Point a1, Point a2, Point p1, Point p2)</td></tr>
<tr class="separator:a80bfc131afebdd7aa895617dbacaaa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe5fd22fa49e0d75b299582d1a4f76b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aebe5fd22fa49e0d75b299582d1a4f76b">isDiscretizedArcColliding</a> (dubins::Arc &amp;a, Point pA, Point pB)</td></tr>
<tr class="separator:aebe5fd22fa49e0d75b299582d1a4f76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729bdbfd1191f178132bfe1f99c22bc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a729bdbfd1191f178132bfe1f99c22bc1">isCollidingWithPolygon</a> (dubins::Arc &amp;a, Polygon p)</td></tr>
<tr class="separator:a729bdbfd1191f178132bfe1f99c22bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca04a876683af27dbfa8cefc7b655874"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aca04a876683af27dbfa8cefc7b655874">isCurveColliding</a> (dubins::Curve &amp;curve, const vector&lt; Polygon &gt; &amp;obstacle_list)</td></tr>
<tr class="separator:aca04a876683af27dbfa8cefc7b655874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce03b7c8e81fc3758e472f38aa084ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#afce03b7c8e81fc3758e472f38aa084ec">drawDubinsArc</a> (dubins::Arc &amp;da)</td></tr>
<tr class="separator:afce03b7c8e81fc3758e472f38aa084ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad92236880efbc81b4f44ac57024d83"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, std::vector&lt; dubins::Curve &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a9ad92236880efbc81b4f44ac57024d83">MDP</a> (const std::vector&lt; Point &gt; &amp;path, unsigned int startIdx, unsigned int arriveIdx, double startAngle, double arriveAngle, double &amp;returnedLength, const vector&lt; Polygon &gt; &amp;obstacle_list)</td></tr>
<tr class="separator:a9ad92236880efbc81b4f44ac57024d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d628521f7d445e696a62e1d7ae4fda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#aa0d628521f7d445e696a62e1d7ae4fda">isPathColliding</a> (vector&lt; Point &gt; vertices, vector&lt; Polygon &gt; obstacle_list)</td></tr>
<tr class="separator:aa0d628521f7d445e696a62e1d7ae4fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab137921db513654a5a0cbbbb04e41b73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ab137921db513654a5a0cbbbb04e41b73">pathSmoothing</a> (int start_index, int finish_index, vector&lt; Point &gt; vertices, vector&lt; Polygon &gt; obstacle_list, vector&lt; Point &gt; &amp;short_path)</td></tr>
<tr class="separator:ab137921db513654a5a0cbbbb04e41b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318eb1ddb436643469a1e076e7961688"><td class="memItemLeft" align="right" valign="top">vector&lt; Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a318eb1ddb436643469a1e076e7961688">RRTplanner</a> (const Polygon &amp;borders, const vector&lt; Polygon &gt; &amp;obstacle_list, const float x0, const float y0, const float xf, const float yf, const string &amp;config_folder)</td></tr>
<tr class="separator:a318eb1ddb436643469a1e076e7961688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f3ef767edcfbba6b63a32d0265500b"><td class="memItemLeft" align="right" valign="top">vector&lt; Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a01f3ef767edcfbba6b63a32d0265500b">completeSmoothing</a> (const vector&lt; Point &gt; &amp;path, const vector&lt; Polygon &gt; &amp;obstacle_list)</td></tr>
<tr class="separator:a01f3ef767edcfbba6b63a32d0265500b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ce5592b75c63c853f30c4eb8b6c883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a36ce5592b75c63c853f30c4eb8b6c883">drawDebugPath</a> (std::vector&lt; Point &gt; path)</td></tr>
<tr class="separator:a36ce5592b75c63c853f30c4eb8b6c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274add89a9a406df4a2c10e4f5a298f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a274add89a9a406df4a2c10e4f5a298f3">drawDebugImage</a> (const Polygon &amp;borders, const vector&lt; Polygon &gt; &amp;obstacle_list, const vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;victim_list)</td></tr>
<tr class="separator:a274add89a9a406df4a2c10e4f5a298f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191a0a4b875ab8e51667a0e1d102634a"><td class="memItemLeft" align="right" valign="top">vector&lt; dubins::Curve &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a191a0a4b875ab8e51667a0e1d102634a">collectVictimsPath</a> (const Polygon &amp;borders, const vector&lt; Polygon &gt; &amp;obstacle_list, const vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;victim_list, float x, float y, float theta, float xf, float yf, float thf, const string &amp;config_folder)</td></tr>
<tr class="separator:a191a0a4b875ab8e51667a0e1d102634a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e444b8fa1e5101e71318775a0247c6b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a1e444b8fa1e5101e71318775a0247c6b">getPointPathLength</a> (const vector&lt; Point &gt; &amp;path)</td></tr>
<tr class="separator:a1e444b8fa1e5101e71318775a0247c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e57884d6d72c214eae050a1980d499"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a79e57884d6d72c214eae050a1980d499">getPosePathLength</a> (const vector&lt; Pose &gt; &amp;path)</td></tr>
<tr class="separator:a79e57884d6d72c214eae050a1980d499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed9f8d3bd9ca7f77e060a0f927680ff"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a1ed9f8d3bd9ca7f77e060a0f927680ff">getPathLength</a> (const vector&lt; dubins::Curve &gt; &amp;multipointPath)</td></tr>
<tr class="separator:a1ed9f8d3bd9ca7f77e060a0f927680ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab247edd9beb1bcd4071f35ba700a7d78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ab247edd9beb1bcd4071f35ba700a7d78">sorByDistance</a> (const pair&lt; int, float &gt; &amp;p1, const pair&lt; int, float &gt; &amp;p2)</td></tr>
<tr class="separator:ab247edd9beb1bcd4071f35ba700a7d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cce2cd1028ac4cbd8932e5e06721bf"><td class="memItemLeft" align="right" valign="top">vector&lt; dubins::Curve &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a11cce2cd1028ac4cbd8932e5e06721bf">bestScoreGreedy</a> (const Polygon &amp;borders, const vector&lt; Polygon &gt; &amp;obstacle_list, const vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;victim_list, float x, float y, float theta, float xf, float yf, float thf, const string &amp;config_folder)</td></tr>
<tr class="separator:a11cce2cd1028ac4cbd8932e5e06721bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7246f78ee75ada13dedc36bd4e354aa9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#a7246f78ee75ada13dedc36bd4e354aa9">planPath</a> (const Polygon &amp;borders, const vector&lt; Polygon &gt; &amp;obstacle_list, const vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;victim_list, const Polygon &amp;gate, const float x, const float y, const float theta, Path &amp;path, const string &amp;config_folder)</td></tr>
<tr class="separator:a7246f78ee75ada13dedc36bd4e354aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac79fbde433a9fb6df9d0b05c3deaac0e"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestudent.html#ac79fbde433a9fb6df9d0b05c3deaac0e">dcImg</a> = cv::Mat(600, 800, CV_8UC3, cv::Scalar(255,255,255))</td></tr>
<tr class="separator:ac79fbde433a9fb6df9d0b05c3deaac0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af56a77ece3c368e8190419f5fa703a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56a77ece3c368e8190419f5fa703a2f">&#9670;&nbsp;</a></span>baricenter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point student::baricenter </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>polygon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the baricenter Point of a utils::Polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>Input polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The baricenter Point. </dd></dl>

</div>
</div>
<a id="afa1ef0c7d0350a8c3a84078bd7cfb14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1ef0c7d0350a8c3a84078bd7cfb14f">&#9670;&nbsp;</a></span>baricenter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::baricenter </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the baricenter coordinates of a utils::Polygon. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygon</td><td>Input polygon. </td></tr>
    <tr><td class="paramname">cx</td><td>Output x coordinate. </td></tr>
    <tr><td class="paramname">cy</td><td>Output y coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11cce2cd1028ac4cbd8932e5e06721bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cce2cd1028ac4cbd8932e5e06721bf">&#9670;&nbsp;</a></span>bestScoreGreedy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;dubins::Curve&gt; student::bestScoreGreedy </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plans a path that maximizes the time-score of the mission. For each victim collected a time-bonus is granted. At each step, the greedy function picks the victim <br  />
 that better improves the final score. To avoid loops and improve the search, the victims to test are ordered by distance from the starting point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borders</td><td>Borders of the arena </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of obstacle polygons. </td></tr>
    <tr><td class="paramname">victim_list</td><td>List of victim polygons. </td></tr>
    <tr><td class="paramname">x</td><td>Starting point x coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>Starting point y coordinate. </td></tr>
    <tr><td class="paramname">theta</td><td>Starting angle. </td></tr>
    <tr><td class="paramname">xf</td><td>Arrival point x coordinate. </td></tr>
    <tr><td class="paramname">yf</td><td>Arrival point y coordinate. </td></tr>
    <tr><td class="paramname">thf</td><td>Arrival angle. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The multi-point dubins curve solution. </dd></dl>

</div>
</div>
<a id="a0b73564a32b0038042221449619b34ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b73564a32b0038042221449619b34ef">&#9670;&nbsp;</a></span>centerGate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::centerGate </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the arrival point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gate</td><td>Gate polygon. </td></tr>
    <tr><td class="paramname">borders</td><td>Arena borders polygon. </td></tr>
    <tr><td class="paramname">x</td><td>Output arrival x coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>Output arrival y coordinate. </td></tr>
    <tr><td class="paramname">theta</td><td>Output arrival angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The baricenter of the gate polygon with the correct arrival angle. </dd></dl>

</div>
</div>
<a id="a191a0a4b875ab8e51667a0e1d102634a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191a0a4b875ab8e51667a0e1d102634a">&#9670;&nbsp;</a></span>collectVictimsPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;dubins::Curve&gt; student::collectVictimsPath </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plans a path in which every victim is collected in the correct order. Calls the planning steps for each sub-path in the following order: RRT planner, path smoothing, multi-point dubins curve problem. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borders</td><td>Borders of the arena </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of obstacle polygons. </td></tr>
    <tr><td class="paramname">victim_list</td><td>List of victim polygons. </td></tr>
    <tr><td class="paramname">x</td><td>Starting point x coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>Starting point y coordinate. </td></tr>
    <tr><td class="paramname">theta</td><td>Starting angle. </td></tr>
    <tr><td class="paramname">xf</td><td>Arrival point x coordinate. </td></tr>
    <tr><td class="paramname">yf</td><td>Arrival point y coordinate. </td></tr>
    <tr><td class="paramname">thf</td><td>Arrival angle. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The multi-point dubins curve solution. </dd></dl>

</div>
</div>
<a id="a01f3ef767edcfbba6b63a32d0265500b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f3ef767edcfbba6b63a32d0265500b">&#9670;&nbsp;</a></span>completeSmoothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;Point&gt; student::completeSmoothing </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to reduce the number of points in a path by combinaning different techniques. The function performs recursive smoothing iteratively until no change is observed. An additional step is performed on the points of the path in reversed order to achieve further smoothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Input path to smooth. </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of obstacle polygons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smoothed path. </dd></dl>

</div>
</div>
<a id="a274add89a9a406df4a2c10e4f5a298f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274add89a9a406df4a2c10e4f5a298f3">&#9670;&nbsp;</a></span>drawDebugImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::drawDebugImage </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws borders, obstacles and victims on a debug image </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borders</td><td>Borders of the arena </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of obstacle polygons. </td></tr>
    <tr><td class="paramname">victim_list</td><td>List of victim polygons. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36ce5592b75c63c853f30c4eb8b6c883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ce5592b75c63c853f30c4eb8b6c883">&#9670;&nbsp;</a></span>drawDebugPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::drawDebugPath </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Point &gt;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the path on a debug image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to draw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afce03b7c8e81fc3758e472f38aa084ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce03b7c8e81fc3758e472f38aa084ec">&#9670;&nbsp;</a></span>drawDubinsArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::drawDubinsArc </td>
          <td>(</td>
          <td class="paramtype">dubins::Arc &amp;&#160;</td>
          <td class="paramname"><em>da</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws a dubins::Arc on a debug image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">da</td><td>Arc to draw. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c862ea36dd735ed630bd4ade893d692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c862ea36dd735ed630bd4ade893d692">&#9670;&nbsp;</a></span>extrinsicCalib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::extrinsicCalib </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; cv::Point3f &gt;&#160;</td>
          <td class="paramname"><em>object_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>tvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs extrinsic calibration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>Input image. </td></tr>
    <tr><td class="paramname">object_points</td><td>Array of object points in the object coordinate space. </td></tr>
    <tr><td class="paramname">camera_matrix</td><td>Input camera matrix. </td></tr>
    <tr><td class="paramname">rvec</td><td>Output rotation vector. </td></tr>
    <tr><td class="paramname">tvec</td><td>Output translation vector. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the function is executed successfully. </dd></dl>

</div>
</div>
<a id="ac147aa0ef901ceb20469551084e92583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac147aa0ef901ceb20469551084e92583">&#9670;&nbsp;</a></span>findGate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::findGate </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>hsv_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polygon &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstudent_1_1Color__config.html">Color_config</a> &amp;&#160;</td>
          <td class="paramname"><em>color_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the gate in the arena given the arena image. Gate color is green. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hsv_img</td><td>HSV input image. </td></tr>
    <tr><td class="paramname">scale</td><td>Scaling factor. </td></tr>
    <tr><td class="paramname">gate</td><td>Polygon that represents the gate. </td></tr>
    <tr><td class="paramname">color_config</td><td>Color bounds configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if gate was found. </dd></dl>

</div>
</div>
<a id="a86371df933f2682ffb543020c09b9b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86371df933f2682ffb543020c09b9b37">&#9670;&nbsp;</a></span>findObstacles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::findObstacles </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>hsv_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstudent_1_1Color__config.html">Color_config</a> &amp;&#160;</td>
          <td class="paramname"><em>color_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the obstacles in the arena given the arena image and dilate to account for robot dimensions. Obstacle color is red. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hsv_img</td><td>HSV input image. </td></tr>
    <tr><td class="paramname">scale</td><td>Scaling factor. </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of output obstacle polygons. </td></tr>
    <tr><td class="paramname">color_config</td><td>Color bounds configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abab4b372a0d7817c60ac1315991a3d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab4b372a0d7817c60ac1315991a3d24">&#9670;&nbsp;</a></span>findPlaneTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::findPlaneTransform </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>cam_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>tvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; cv::Point3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_points_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest_image_points_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>plane_transf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates a perspetive transform from four pairs of the corresponding points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cam_matrix</td><td>Input camera matrix. </td></tr>
    <tr><td class="paramname">rvec</td><td>Output rotation vector. </td></tr>
    <tr><td class="paramname">tvec</td><td>Output translation vector. </td></tr>
    <tr><td class="paramname">object_points_plane</td><td>Array of object points. </td></tr>
    <tr><td class="paramname">dest_image_points_plane</td><td>Coordinates of the corresponding quadrangle vertices in the destination image. </td></tr>
    <tr><td class="paramname">plane_transf</td><td>Output perspective transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae962c3cdbd728fb697fc39c8e946ffc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae962c3cdbd728fb697fc39c8e946ffc2">&#9670;&nbsp;</a></span>findRobot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::findRobot </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polygon &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the robot in the arena given the arena image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>Input image. </td></tr>
    <tr><td class="paramname">scale</td><td>Scaling factor. </td></tr>
    <tr><td class="paramname">triangle</td><td>Triangular polygon representing the robot. </td></tr>
    <tr><td class="paramname">x</td><td>Robot position x coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>Robot position y coordinate. </td></tr>
    <tr><td class="paramname">theta</td><td>Robot position angle. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if robot was found. </dd></dl>

</div>
</div>
<a id="ae736e2baa1e7b96612cea01993e5969a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae736e2baa1e7b96612cea01993e5969a">&#9670;&nbsp;</a></span>findVictims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::findVictims </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>hsv_img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structstudent_1_1Color__config.html">Color_config</a> &amp;&#160;</td>
          <td class="paramname"><em>color_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the victims in the arena given the arena image and detects victim number. Victim color is green. Number is detected by template matching. Template matching is performed by extracting the axes-aligned minimal bounding rectangle for each region of interest and comparing it with the templates in four 90 degree orientations to maximize the matching score. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hsv_img</td><td>HSV input image. </td></tr>
    <tr><td class="paramname">scale</td><td>Scaling factor. </td></tr>
    <tr><td class="paramname">victim_list</td><td>List of output victim polygons. </td></tr>
    <tr><td class="paramname">color_config</td><td>Color bounds configuration. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if victims were found. </dd></dl>

</div>
</div>
<a id="a71ecb46160bae8229c5545d81499cbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ecb46160bae8229c5545d81499cbe1">&#9670;&nbsp;</a></span>genericImageListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::genericImageListener </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves an image when S key is pressed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>Input image. </td></tr>
    <tr><td class="paramname">topic</td><td>Image topic name. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ed9f8d3bd9ca7f77e060a0f927680ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed9f8d3bd9ca7f77e060a0f927680ff">&#9670;&nbsp;</a></span>getPathLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float student::getPathLength </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; dubins::Curve &gt; &amp;&#160;</td>
          <td class="paramname"><em>multipointPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the length of a multi-point dubins curve. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multipointPath</td><td>Input dubins curve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The legth of the multi-point dubins curve. </dd></dl>

</div>
</div>
<a id="a1e444b8fa1e5101e71318775a0247c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e444b8fa1e5101e71318775a0247c6b">&#9670;&nbsp;</a></span>getPointPathLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float student::getPointPathLength </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the length of a path of points. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Input path points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The legth of the path. </dd></dl>

</div>
</div>
<a id="a79e57884d6d72c214eae050a1980d499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e57884d6d72c214eae050a1980d499">&#9670;&nbsp;</a></span>getPosePathLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float student::getPosePathLength </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Pose &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the length of a path of poses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Input path poses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The legth of the path. </dd></dl>

</div>
</div>
<a id="a6f0e094ceaac869cef0f5056d3a79452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0e094ceaac869cef0f5056d3a79452">&#9670;&nbsp;</a></span>imageUndistort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::imageUndistort </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>cam_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>dist_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Undistorts the input image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>Input distorted image. </td></tr>
    <tr><td class="paramname">img_out</td><td>Output corrected image. </td></tr>
    <tr><td class="paramname">cam_matrix</td><td>Input camera matrix. </td></tr>
    <tr><td class="paramname">dist_coeffs</td><td>Input vector of distortion coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14b0bbd19b5e7e10ee5c0c895266e72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b0bbd19b5e7e10ee5c0c895266e72e">&#9670;&nbsp;</a></span>isArcColliding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::isArcColliding </td>
          <td>(</td>
          <td class="paramtype">dubins::Arc&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>pB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a dubins::Arc is colliding with a segment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Arc to check. </td></tr>
    <tr><td class="paramname">pA</td><td>First point of the segment. </td></tr>
    <tr><td class="paramname">pB</td><td>Second point of the segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if arc and segment are intersecting. </dd></dl>

</div>
</div>
<a id="a729bdbfd1191f178132bfe1f99c22bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729bdbfd1191f178132bfe1f99c22bc1">&#9670;&nbsp;</a></span>isCollidingWithPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::isCollidingWithPolygon </td>
          <td>(</td>
          <td class="paramtype">dubins::Arc &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polygon&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a dubins::Arc is colliding with a given polygon. A dubins::Arc can also be a segment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Arc to check. </td></tr>
    <tr><td class="paramname">p</td><td>The polygon to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the arc is intersecting the polygon. </dd></dl>

</div>
</div>
<a id="aca04a876683af27dbfa8cefc7b655874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca04a876683af27dbfa8cefc7b655874">&#9670;&nbsp;</a></span>isCurveColliding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::isCurveColliding </td>
          <td>(</td>
          <td class="paramtype">dubins::Curve &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a dubins::Curve is colliding with any obstacle. The function performs three checks, one for each dubins::Arc component of the dubins::Curve. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>Curve to check. </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>The list of obstacle polygons to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the curve is intersecting any obstacle. </dd></dl>

</div>
</div>
<a id="aebe5fd22fa49e0d75b299582d1a4f76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe5fd22fa49e0d75b299582d1a4f76b">&#9670;&nbsp;</a></span>isDiscretizedArcColliding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::isDiscretizedArcColliding </td>
          <td>(</td>
          <td class="paramtype">dubins::Arc &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>pA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>pB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Approximate approach to check for collisions between dubins::Arc and segment using arc discretization. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Arc to check. </td></tr>
    <tr><td class="paramname">pA</td><td>First point of the segment. </td></tr>
    <tr><td class="paramname">pB</td><td>Second point of the segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the arc and segment are intersecting. </dd></dl>

</div>
</div>
<a id="aa0d628521f7d445e696a62e1d7ae4fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d628521f7d445e696a62e1d7ae4fda">&#9670;&nbsp;</a></span>isPathColliding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::isPathColliding </td>
          <td>(</td>
          <td class="paramtype">vector&lt; Point &gt;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Polygon &gt;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a path is colliding with any obstacle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>List of points in the path. </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of obstacle polygons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the path is colliding with any obstacle. </dd></dl>

</div>
</div>
<a id="a80bfc131afebdd7aa895617dbacaaa54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bfc131afebdd7aa895617dbacaaa54">&#9670;&nbsp;</a></span>isSegmentColliding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::isSegmentColliding </td>
          <td>(</td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if a segment is colliding with another segment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>First point of the first segment. </td></tr>
    <tr><td class="paramname">a2</td><td>Second point of the second segment. </td></tr>
    <tr><td class="paramname">p1</td><td>First point of the second segment. </td></tr>
    <tr><td class="paramname">p2</td><td>Second point of the second segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the segments are intersecting. </dd></dl>

</div>
</div>
<a id="ab99b5e1d9883a93f4f58b47121a06a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99b5e1d9883a93f4f58b47121a06a8b">&#9670;&nbsp;</a></span>loadImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::loadImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads images from the file system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_out</td><td>Output image. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
    <tr><td class="paramname">initialized</td><td>True if images were found. </td></tr>
    <tr><td class="paramname">img_list</td><td>List of images to load. </td></tr>
    <tr><td class="paramname">idx</td><td>Index of the current image. </td></tr>
    <tr><td class="paramname">function_call_counter</td><td>Iterations count. </td></tr>
    <tr><td class="paramname">freeze_img_n_step</td><td>Hold the current image for this number of iterations. </td></tr>
    <tr><td class="paramname">current_img</td><td>Store the image for a period, avoid to load it from file every time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ad92236880efbc81b4f44ac57024d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad92236880efbc81b4f44ac57024d83">&#9670;&nbsp;</a></span>MDP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool,std::vector&lt;dubins::Curve&gt; &gt; student::MDP </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>arriveIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>arriveAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>returnedLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the shortest multi-point dubins curve for the given path. The recursive function has two base cases: two-points dubins::Curve and three-points dubins::Curve. The recursion step is called on N-points dubins::Curve. Free angles are chosen among a number of test angles. The choice is optimized by adding the average between the fixed angles. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>List of points in the path. </td></tr>
    <tr><td class="paramname">startIdx</td><td>Recursion start index. </td></tr>
    <tr><td class="paramname">arriveIdx</td><td>Recursion arrival index. </td></tr>
    <tr><td class="paramname">startAngle</td><td>Starting angle. </td></tr>
    <tr><td class="paramname">arriveAngle</td><td>Arrival angle. </td></tr>
    <tr><td class="paramname">returnedLength</td><td>Output length of the shortest path. </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of obstacle polygons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with true if the path does not collide and the shortest multi-point dubins::Curve. </dd></dl>

</div>
</div>
<a id="ab137921db513654a5a0cbbbb04e41b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab137921db513654a5a0cbbbb04e41b73">&#9670;&nbsp;</a></span>pathSmoothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::pathSmoothing </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>finish_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Point &gt;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Polygon &gt;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>short_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to reduce the number of points in a path recursively. Splits the path into two and performs recursion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_index</td><td>Index of the starting point. </td></tr>
    <tr><td class="paramname">finish_index</td><td>Index of the arrival point. </td></tr>
    <tr><td class="paramname">vertices</td><td>Path to smooth. </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of obstacle polygons. </td></tr>
    <tr><td class="paramname">short_path</td><td>Output smoothed path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a path with fewer points was found. </dd></dl>

</div>
</div>
<a id="a7246f78ee75ada13dedc36bd4e354aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7246f78ee75ada13dedc36bd4e354aa9">&#9670;&nbsp;</a></span>planPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::planPath </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plans a path according to the mission selected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borders</td><td>Borders of the arena </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of obstacle polygons. </td></tr>
    <tr><td class="paramname">victim_list</td><td>List of victim polygons. </td></tr>
    <tr><td class="paramname">gate</td><td>Gate polygon. </td></tr>
    <tr><td class="paramname">x</td><td>Starting point x coordinate. </td></tr>
    <tr><td class="paramname">y</td><td>Starting point y coordinate. </td></tr>
    <tr><td class="paramname">theta</td><td>Starting angle. </td></tr>
    <tr><td class="paramname">path</td><td>Output planned path. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the path was planned correctly. </dd></dl>

</div>
</div>
<a id="aacb26aebecf0a57160aadff8f4ac5429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb26aebecf0a57160aadff8f4ac5429">&#9670;&nbsp;</a></span>pointsEquals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::pointsEquals </td>
          <td>(</td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point&#160;</td>
          <td class="paramname"><em>pb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the two Points have the same x and y coordinates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pa</td><td>First Point. </td></tr>
    <tr><td class="paramname">pb</td><td>Second Point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The test result. </dd></dl>

</div>
</div>
<a id="af4f3ef58b787dd48aa05c05e4dc4e8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f3ef58b787dd48aa05c05e4dc4e8b7">&#9670;&nbsp;</a></span>processMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::processMap </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, Polygon &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>victim_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polygon &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates the map processing starting from an image of the arena. Converts the input image in HSV space for better color detection and calls the functions that detect gate, obstacles and victims. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>Input image. </td></tr>
    <tr><td class="paramname">scale</td><td>Scaling factor. </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of output obstacle polygons. </td></tr>
    <tr><td class="paramname">victim_list</td><td>List of output victim polygons. </td></tr>
    <tr><td class="paramname">gate</td><td>Polygon that represents the gate. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if function was executed successfully. </dd></dl>

</div>
</div>
<a id="abdbe12fa5f061a35e0d3df30bec1a872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbe12fa5f061a35e0d3df30bec1a872">&#9670;&nbsp;</a></span>read_colors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structstudent_1_1Color__config.html">Color_config</a> student::read_colors </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads color bounds configuration from file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a318eb1ddb436643469a1e076e7961688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318eb1ddb436643469a1e076e7961688">&#9670;&nbsp;</a></span>RRTplanner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;Point&gt; student::RRTplanner </td>
          <td>(</td>
          <td class="paramtype">const Polygon &amp;&#160;</td>
          <td class="paramname"><em>borders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; Polygon &gt; &amp;&#160;</td>
          <td class="paramname"><em>obstacle_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>xf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>yf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plans the path with RRT. Prepares a file with input data: starting point, arrival point, borders and obstacles. The RRT library will output another file with the coordinates of the points in the path found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borders</td><td>Borders of the arena. </td></tr>
    <tr><td class="paramname">obstacle_list</td><td>List of obstacle polygons. </td></tr>
    <tr><td class="paramname">x0</td><td>Starting point x coordinate. </td></tr>
    <tr><td class="paramname">y0</td><td>Starting point y coordinate. </td></tr>
    <tr><td class="paramname">xf</td><td>Arrival point x coordinate. </td></tr>
    <tr><td class="paramname">yf</td><td>Arrival point y coordinate. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The planned path. </dd></dl>

</div>
</div>
<a id="ab247edd9beb1bcd4071f35ba700a7d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab247edd9beb1bcd4071f35ba700a7d78">&#9670;&nbsp;</a></span>sorByDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool student::sorByDistance </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; int, float &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; int, float &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Custom sorting function for pairs of indexed distances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First &lt;index,distance&gt; pair. </td></tr>
    <tr><td class="paramname">p2</td><td>Second &lt;index,distance&gt; pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first distance value is smaller. </dd></dl>

</div>
</div>
<a id="ac31ebca52b34d038f0ef94d7aa81be13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31ebca52b34d038f0ef94d7aa81be13">&#9670;&nbsp;</a></span>tune_color_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::tune_color_parameters </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a series of panels to tune the color threshold for better detection </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Reference image for color tuning. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1e350455611261c051053268de6d579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e350455611261c051053268de6d579">&#9670;&nbsp;</a></span>unwarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void student::unwarp </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>img_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>transf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>config_folder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies a perspective transform to an image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img_in</td><td>Input image. </td></tr>
    <tr><td class="paramname">img_out</td><td>Output unwarped image. </td></tr>
    <tr><td class="paramname">transf</td><td>Transformation matrix. </td></tr>
    <tr><td class="paramname">config_folder</td><td>Configuration folder path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac79fbde433a9fb6df9d0b05c3deaac0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79fbde433a9fb6df9d0b05c3deaac0e">&#9670;&nbsp;</a></span>dcImg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat student::dcImg = cv::Mat(600, 800, CV_8UC3, cv::Scalar(255,255,255))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Image used for debug drawing. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.19
</small></address>
</body>
</html>
